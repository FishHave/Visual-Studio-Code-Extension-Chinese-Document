# 笔记本

笔记本API允许Visual Studio Code扩展用笔记本打开文件，执行笔记本代码单元格并用多种可交互格式渲染笔记本输出。您也许知道一个如Jupyter Notebook或Google Colab一样有名的笔记本接口——笔记本API容许在Visual Studio Code中类似的体验

## 笔记本各部分

一个笔记本由连续的单元格和它们的输出组成。笔记本的单元格不是Markdown单元格就是代码单元格，并且在VS Code核心中渲染。输出可以有各种各样的格式。一些例如普通文本、JSON、图像和HTML输出格式由VS Code核心渲染。其他的如应用程序具体数据或交互小程序由扩展渲染

笔记本中的单元格在文件系统由`NotebookSerializer`读写，它处理从文件系统读取并转换数据为单元格描述并保持修改笔记本到文件系统。笔记本的**代码单元格**可以由`NotebookController`执行，它拿取单元格中的内容并从中在从普通文本到格式化文档或可交互小程序的多种格式产生0或更多输出。应用程序具体输出格式和可交互小程序输出由`NotebookRenderer`渲染

可视化为：

![](https://code.visualstudio.com/assets/api/extension-guides/notebook/architecture-overview.png)

## 序列化器

[NotebookSerializer API Reference](https://github.com/microsoft/vscode/blob/e1a8566a298dcced016d8e16db95c33c270274b4/src/vs/vscode.d.ts#L11865-L11884)

一个`NotebookSerializer`负责序列化一个笔记本为字节并反序列化字节为笔记本，它包括一系列Markdown和代码单元格。它同样负责相互转换：拿取`NotebookData`并转换数据为序列化字节来保存

例如：
- [JSON笔记本序列化器](https://github.com/microsoft/notebook-extension-samples/tree/main/notebook-serializer)：简单的示例笔记本，将JSON输入输出美化为自定义`NotebookRendered`
- [Markdown序列化器](https://github.com/microsoft/vscode-markdown-notebook)：在笔记本中打开并编辑Markdown文件

### 示例

在这个示例中，我们构建一个简化的笔记本供应者扩展来在[Jupyter笔记本格式](https://nbformat.readthedocs.io/en/latest/format_description.html)中查看文件

一个笔记本序列化器在如下`package.json`下的`contributes.notebooks`字段中声明：

```json
{
    ...
    "contributes": {
        ...
        "notebooks": [
            {
                "type": "my-notebook",
                "displayName": "My Notebook",
                "selector": [
                    {
                        "filenamePattern": "*.notebook"
                    }
                ]
            }
        ]
    }
}
```

笔记本序列化器随后在扩展启用事件中注册

```typescript
import { TextDecoder, TextEncoder } from 'util';
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.workspace.registerNotebookSerializer('my-notebook', new SampleSerializer())
  );
}

interface RawNotebook {
  cells: RawNotebookCell[];
}

interface RawNotebookCell {
  source: string[];
  cell_type: 'code' | 'markdown';
}

class SampleSerializer implements vscode.NotebookSerializer {
  async deserializeNotebook(
    content: Uint8Array,
    _token: vscode.CancellationToken
  ): Promise<vscode.NotebookData> {
    var contents = new TextDecoder().decode(content);

    let raw: RawNotebookCell[];
    try {
      raw = (<RawNotebook>JSON.parse(contents)).cells;
    } catch {
      raw = [];
    }

    const cells = raw.map(
      item =>
        new vscode.NotebookCellData(
          item.cell_type === 'code'
            ? vscode.NotebookCellKind.Code
            : vscode.NotebookCellKind.Markup,
          item.source.join('\n'),
          item.cell_type === 'code' ? 'python' : 'markdown'
        )
    );

    return new vscode.NotebookData(cells);
  }

  async serializeNotebook(
    data: vscode.NotebookData,
    _token: vscode.CancellationToken
  ): Promise<Uint8Array> {
    let contents: RawNotebookCell[] = [];

    for (const cell of data.cells) {
      contents.push({
        cell_type: cell.kind === vscode.NotebookCellKind.Code ? 'code' : 'markdown',
        source: cell.value.split(/\r?\n/g)
      });
    }

    return new TextEncoder().encode(JSON.stringify(contents));
  }
}
```

现在尝试运行您的扩展并打开一个保存于`.notebook`格式的Jupyter笔记本格式文件

![](https://code.visualstudio.com/assets/api/extension-guides/notebook/ipynb-simple-provider.png)

您应该可以打开Jupyter格式笔记本并用普通文本和渲染的Markdown查看它们的单元格并编辑单元格。然而，输出并不会保存在磁盘中；为了保存输出，您需要从`NotebookData`序列化并反序列化输出

要运行一个单元格，您需要实现一个`NotebookController`

## 控制器

[NotebookController API参考]

一个`NotebookController`负责处理一个**代码单元格**并执行代码产生一些或没有输出

一个控制器直接关联笔记本序列化器并在创建控制器时通过设置`NotebookController#notebookType`属性关联一类笔记本。然后控制器通过将控制器推入在扩展启用中的扩展订阅来全局注册

```typescript
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(new Controller());
}

class Controller {
  readonly controllerId = 'my-notebook-controller-id';
  readonly notebookType = 'my-notebook';
  readonly label = 'My Notebook';
  readonly supportedLanguages = ['python'];

  private readonly _controller: vscode.NotebookController;
  private _executionOrder = 0;

  constructor() {
    this._controller = vscode.notebooks.createNotebookController(
      this.controllerId,
      this.notebookType,
      this.label
    );

    this._controller.supportedLanguages = this.supportedLanguages;
    this._controller.supportsExecutionOrder = true;
    this._controller.executeHandler = this._execute.bind(this);
  }

  private _execute(
    cells: vscode.NotebookCell[],
    _notebook: vscode.NotebookDocument,
    _controller: vscode.NotebookController
  ): void {
    for (let cell of cells) {
      this._doExecution(cell);
    }
  }

  private async _doExecution(cell: vscode.NotebookCell): Promise<void> {
    const execution = this._controller.createNotebookCellExecution(cell);
    execution.executionOrder = ++this._executionOrder;
    execution.start(Date.now()); // 保持追踪经过的时间来执行单元格

    /* 在这执行一些东西；未实现 */

    execution.replaceOutput([
      new vscode.NotebookCellOutput([
        vscode.NotebookCellOutputItem.text('Dummy output text!')
      ])
    ]);
    execution.end(true, Date.now());
  }
}
```

如果您单独从序列化器中发布一个提供`NotebookController`扩展，那么添加如`notebookKernel<ViewTypeUpperCamelCased>`的入口到`package.json`的`keywords`。例如，如果您在为`github-issues`笔记本类型发布一个可替代核心，您应当添加一个关键词`notebookKernelGithubIssues`到您的扩展

示例：

- [Github Issues Notebook](https://github.com/microsoft/vscode-github-issue-notebooks/blob/93359d842cd01dfaef0a78b620c5a3b4cf5c2e38/src/extension/notebookProvider.ts#L29): 执行Github Issues查询的控制器
- [REST Book](https://github.com/tanhakabir/rest-book/blob/main/src/extension/notebookKernel.ts): 运行REST查询的控制器
- [Regexper notebooks](https://github.com/jrieken/vscode-regex-notebook/blob/master/src/extension/extension.ts#L56)： 可视化正则表达式的控制器

## 输出类型

输出必须是三种格式之一：文本输出、错误或富输出。一个核心可能为一个单元格的执行提供多种输出，在这种情况下它们将呈列表显示

如文本输出类的简单输出、错误输出或“简单”类的富输出（HTML、Markdown、JSON之类）由VS Code核心渲染，然而应用程序特定富输出类型由[NotebookRendered](#NotebookRendered)渲染。一个扩展也许可选自渲染“简单的”富输出，例如给Markdown输出添加LaTex支持

![](https://code.visualstudio.com/assets/api/extension-guides/notebook/kernel.png)

### 文本输出

文本输出是最简单的输出格式，并且与您熟悉的许多交互式解释器相似。它们仅由在单元格输出元素渲染作普通文本的`text`字段组成

```typescript
vscode.NotebookCellOutputItem.text('This is the output...');
```

![](https://code.visualstudio.com/assets/api/extension-guides/notebook/text-output.png)

### 错误输出

错误输出对于用一致可理解的风格显示运行时错误来说很有用。它们支持标准`Error`对象

```typescript
try {
  /* 一些代码 */
} catch (error) {
  vscode.NotebookCellOutputItem.error(error);
}
```

![](https://code.visualstudio.com/assets/api/extension-guides/notebook/error-output.png)

### 富输出

富输出是最高级的显示单元格输出的形式。它们允许提供许多不同由MIME类型键入的输出数据表现。例如，如果一个单元格输出要表现一个GitHub Issue，核心可能会产生一个`data`字段有几个属性的富输出

- `text/html`字段包含一个Issue的格式化视图
- `text/x-json`字段包含一个机器可读视图
- `application/github-issue`可以被`NotebookRendered`能够用于创建一个Issue的完全可交互视图

在这种情况下，`text/html`和`text/x-json`视图将被VS Code本地渲染，但`application/github-issue`视图如果没有`NotebookRendered`注册在MIME类型，将显示错误

```typescript
execution.replaceOutput([new vscode.NotebookCellOutput([
                            vscode.NotebookCellOutputItem.text('<b>Hello</b> World', 'text/html'),
                            vscode.NotebookCellOutputItem.json({ hello: 'world' }),
                            vscode.NotebookCellOutputItem.json({ custom-data-for-custom-renderer: 'data' }, 'application/custom'),
                        ])]);
```

默认，VS Code可以渲染下列MIME类型：

- application/javascript
- text/html
- image/svg+xml
- text/markdown
- image/png
- image/jpg
- text/plain

VS Code将在内建编辑器渲染这些MIME类型为代码：

- text/x-json
- text/x-javascript
- text/x-html
- text/x-rust
- ... text/x-LANGUAGE_ID 给任何其他内建或已安装语言

笔记本使用内建编辑器显示一些Rust代码

![](https://code.visualstudio.com/assets/api/extension-guides/notebook/rust-output.png)

为了显示一个可选择的MIME类型，`NotebookRendered`必须为那个MIME类型注册

## 笔记本渲染器

笔记本渲染器负责提供特定MIME类型输出数据一个已渲染的视图。一个由输出单元格共享的渲染器可以维持单元格间全局状态。已渲染视图的复杂都可以从简单的静态HTML到动态完全可交互小程序。在这小节，我们将探索不同的渲染GitHub Issue输出表现的技巧

您可以快速从您的Yeoman生成器快速使用样本文件。要这么做，首先使用下面代码安装Yeoman和VS Code生成器：

```shell
npm install -g yo generator-code
```

然后，运行`yo code`并选择`New Notebook Renderer (TypeScript)`

如果您不使用这个模板，您只需确保您添加了`notebookRendered`到您的扩展中的`package.json`里的`keywords`，并在扩展名称或简介的某些地方提及它的MIME类型，如此用户可以找到您的渲染器

### 一个简单、无交互的渲染器

渲染器通过在扩展中的`package.json`贡献`contributes.notebookRenderer`属性为一套MIME类型而声明。这个渲染器将工作于`ms-vscode.github-issue-notebook/github-issue`格式的输入，它是我们假定一些已安装的控制器能够提供的：

```json
{
  "activationEvents": ["...."],
  "contributes": {
    ...
    "notebookRenderer": [
      {
        "id": "github-issue-renderer",
        "displayName": "GitHub Issue Renderer",
        "entrypoint": "./out/renderer.js",
        "mimeTypes": [
          "ms-vscode.github-issue-notebook/github-issue"
        ]
      }
    ]
  }
}
```
